---
layout: post
title:  Markowitz’s Mean-Variance Optimisation (MVO) model
categories: [Financial Engineering]
---

The Markowitz’s Mean-Variance Optimisation (MVO) model provides a method of selecting the optimal portfolio composition of investment assets by making a trade off between the expected returns and the risk of the potential portfolios (Luenberger, 1997). Using this method, the optimal composition of a portfolio was determined from the choice of 10 JSE stocks. The mean, variance and covariance matrix were determined by considering the historical data of these stocks (downloaded from [Investing.com](http://pygments.org/). The stocks in question being:
1. Anglo American PLC (AGLJ) 
2. Aveng Ltd (AEGL) 
3. Exxaro Resources Ltd (EXXJ) 
4. Kumba Iron Ore Ltd (KIOJ) 
5. Mr Price Group Ltd (MRPJ) 
6. MTN Group Ltd (MTNJ) 
7. RMB Holdings Ltd (RMHJ) 
8. Santam (SNTJ) 
9. Sasol Ltd (SOLJ) 
10. Shoprite Holdings Ltd (SHPJ)

The historical data timeline was 07 Sept 2016 to 07 Sept 2022 (on a daily basis).  The time series of the “Total Returns” of the the assets is presented in Figure 1.

![](/images/reverie-demo.png)

## Calulating the rates of return of each stock
$$ r_{it} = \frac{I_{i,t} - I_{i,t-1}}{I_{i,t-1}}$$

  Where $I_{it}$ denotes the "Total Return" (Close price) for stocks $i=[1,10]$ and $t = 0,...,T$ where $t=0$ corresponds to the start date and $t=T$ to the end date. For each stock $i$, the raw data $I_{it}$ for $t=0,...,T$ can be converted to rates of return $r_{it}$ with $t = 1,...,T$

```python
returns = (stocks/stocks.shift(1))

returns
```

# Log returns
$$log \ r_{it} = log \frac{I_{i,t} - I_{i,t-1}}{I_{i,t-1}}$$
We compute the log returns to deal with the disparity in orders of magnitude between the rates of return of the different stocks

```python
# Log returns
log_returns = np.log(returns)

log_returns
```

# Robust Optimisation approach
We will generate all possible portfolios. This method is recommended by Michaud (1998) to mitigate the fundamental weakness of the Markowitz model, namely, the solution found from the model is extremely sensitive to small changes in the data. Only a small change in one $\mu_{i}$ may result in a completely different portfolio $w$. Therefore, a robust optimisation approach provides an alternative approach to mitigating the model's sensitivity

## Efficient Markowitz Frontier
With the mean and covariance known, the efficient frontier can be determined by finding the solution $w$ where:
$$\begin{align*} min_{w} \ \  & w^{T} \sum w \\ subject \ to \ \ & \mu^{t}w \geq R_{min} \\ & w \geq 0 \\ & 1^{T} w = 1 \end{align*}$$
```python
# Efficient Markowitz Frontier
target_returns = np.linspace(0, 0.15, 50
volatility_opt = []
E = df_returns.mean()

def minimize_Vol(w):
    w = np.array(
    V = np.sqrt(np.dot(w.T, np.dot(Cov_log,w)))
    return V

def get_Return(w):
    w = np.array(w)
    R = np.sum(E*w)
	return R


def checkSumToOne(w):
    return np.sum(w)-1

w0 = [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]
bounds = ((0,1),(0,1),(0,1),(0,1),(0,1),(0,1),(0,1),(0,1),(0,1),(0,1))

for ret in target_returns:
    #find the point with opt volatility
    constraints = ({'type':'eq', 'fun':checkSumToOne},
                   {'type':'eq', 'fun': lambda w: get_Return(w) - ret})
    opt = minimize(minimize_Vol, w0,method='SLSQP',bounds=bounds, 
                   constraints=constraints)
    #save optimal volatility values
    volatility_opt.append(opt['fun'])
```

![](/images/reverie-demo.png)

![](/images/reverie-demo.png)


